<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: hobbes</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">hobbes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>a language, embedded compiler, and runtime for efficient dynamic expression evaluation, data storage and analysis</p>
<table class="doxtable">
<tr>
<th>section </th><th align="center">description  </th></tr>
<tr>
<td><a href="#building">Building</a> </td><td align="center">how to build and install hobbes </td></tr>
<tr>
<td><a href="#embedding">Embedding</a> </td><td align="center">use hobbes in C++ programs </td></tr>
<tr>
<td><a href="#evaluation">Evaluation</a> </td><td align="center">evaluate basic hobbes expressions </td></tr>
<tr>
<td><a href="#storage">Storage</a> </td><td align="center">record data for out-of-band analysis </td></tr>
<tr>
<td><a href="#networking">Networking</a> </td><td align="center">interact with remote hobbes processes </td></tr>
<tr>
<td><a href="#comprehensions">Comprehensions</a> </td><td align="center">transform/sort/join/filter/group sequences for data analysis </td></tr>
<tr>
<td><a href="#pat-match">Pattern Matching</a> </td><td align="center">efficiently classify and destructure data </td></tr>
<tr>
<td><a href="#parsing">Parsing</a> </td><td align="center">parse text with LALR(1) grammars </td></tr>
<tr>
<td><a href="#type-classes">Type Classes</a> </td><td align="center">overloading and compile-time calculation </td></tr>
<tr>
<td><a href="#unqualifiers">Unqualifier Modules</a></td><td align="center">user-defined "compiler plugins" for custom constraint handling </td></tr>
</table>
<h2>Building <a class="anchor" id="building"></a></h2>
<p>To build hobbes, you will need <a href="http://llvm.org/">LLVM</a> 3.3 or later, <a href="http://cmake.org/">cmake</a> 3.4 or later, <a href="https://gcc.gnu.org/">GNU gcc</a> 4.8 or later, and a version 2.5 or later Linux kernel.</p>
<p>With LLVM, cmake, and g++ installed, after downloading this code you should be able to build and install hobbes just by running:</p>
<div class="fragment"><div class="line">$ cmake .</div><div class="line">$ make</div><div class="line">$ make install</div></div><!-- fragment --><p>Depending on where you've installed LLVM, this might not work until you give cmake the path to LLVM's cmake modules. In particular, you want the path to LLVM's <code>LLVMConfig.cmake</code> file. If you set the environment variable <code>LLVM_DIR</code> to point to that directory, then the previous steps should complete successfully.</p>
<p>The build process will produce a static library, <code>libhobbes.a</code>, which can be linked into a C++ executable (if you want to use hobbes in a .so instead, the build produces a different static library to use, <code>libhobbes-pic.a</code>).</p>
<p>In addition, the build process will produce two utility programs, <code>hi</code> and <code>hog</code>. The <code>hi</code> program is a basic interactive interpreter for hobbes expressions and the <code>hog</code> program will efficiently record structured data produced by applications into data files (these files can be loaded and queried at the same time by <code>hi</code>). The source code for these programs can be informative as well, because they demonstrate many different aspects of the hobbes API.</p>
<h2>Embedding <a class="anchor" id="embedding"></a></h2>
<p>Let's consider how to embed hobbes in a simple C++ program. This code implements a very basic shell, similar to <code>hi</code>:</p>
<div class="fragment"><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;stdexcept&gt;</div><div class="line">#include &lt;hobbes/hobbes.H&gt;</div><div class="line"></div><div class="line">int main() {</div><div class="line">  hobbes::cc c;</div><div class="line"></div><div class="line">  while (std::cin) {</div><div class="line">    std::cout &lt;&lt; &quot;&gt; &quot; &lt;&lt; std::flush;</div><div class="line"></div><div class="line">    std::string line;</div><div class="line">    std::getline(std::cin, line);</div><div class="line">    if (line == &quot;:q&quot;) break;</div><div class="line"></div><div class="line">    try {</div><div class="line">      c.compileFn&lt;void()&gt;(&quot;print(&quot; + line + &quot;)&quot;)();</div><div class="line">    } catch (std::exception&amp; ex) {</div><div class="line">      std::cout &lt;&lt; &quot;*** &quot; &lt;&lt; ex.what();</div><div class="line">    }</div><div class="line"></div><div class="line">    std::cout &lt;&lt; std::endl;</div><div class="line">    hobbes::resetMemoryPool();</div><div class="line">  }</div><div class="line"></div><div class="line">  return 0;</div><div class="line">}</div></div><!-- fragment --><p>First, to compile any expression we need to construct a <code>hobbes::cc</code> object. Then, in the context of an exception handler, we can compile functions out of this <code>hobbes::cc</code> object with the <code>compileFn</code> method, giving it the type we expect back (<code>void()</code> in this case) and also a string that we expect can compile to a value of that type. If any stage of compilation fails (parse error, type mismatch, etc) then an exception with details about the failure will be raised. Finally, we call <code>hobbes::resetMemoryPool()</code> to release any memory that might have been dynamically allocated by our compiled expression (that is, memory allocated <em>by</em> compiled expressions but not the compiled functions themselves &ndash; those are released only when <code>hobbes::cc</code> is destroyed or when <code>hobbes::cc::releaseMachineCode</code> is used to destroy them).</p>
<p>When a compiled function decides to allocate memory, that allocation happens out of a "memory region". A memory region is a dynamically-growable sequence of bytes where allocations come from, and it is deallocated in bulk when <code>hobbes::resetMemoryPool()</code> is called. This makes allocation and deallocation very efficient, but requires some thought to establish "logical transaction" boundaries. The active memory region is thread-local, so you can use the same function pointer in several threads concurrently without worrying about synchronization issues.</p>
<p>Finally, if we put the above program in a file called "test.cpp" then we can build it like this:</p>
<p>``<code> $ g++ -pthread -std=c++11 -I &lt;path-to-hobbes-headers&gt; -I &lt;path-to-llvm-headers&gt; test.cpp -o test -L &lt;path-to-hobbes-libs&gt; -lhobbes -ldl -lrt -ltinfo -lz -L &lt;path-to-llvm-libs&gt;</code>llvm-config &ndash;libs x86asmparser x86codegen x86 mcjit passes` </p><div class="fragment"><div class="line">The explicit path statements may not be necessary depending on where/how LLVM and hobbes have been installed on your system.  The inline invocation of the `llvm-config` program is typical with users of LLVM, to avoid explicitly listing several libraries.</div><div class="line"></div><div class="line">If everything worked correctly, we should now have a simple shell where we can evaluate hobbes expressions.</div><div class="line"></div><div class="line">## Evaluation &lt;a name=&quot;evaluation&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">Now that we have a working shell, we can experiment with expressions to get a sense of how the hobbes language works.  To start with, we have some typical constant values:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>'c' </p>
</blockquote>
<p>'c' </p><blockquote class="doxtable">
<p>42 </p>
</blockquote>
<p>42 </p><blockquote class="doxtable">
<p>3.14159 </p>
</blockquote>
<p>3.14159 </p><div class="fragment"><div class="line">In total, these are the set of supported primitive types/constants:</div><div class="line"></div><div class="line">|name  |example|description                                         |</div><div class="line">|------|-------|:--------------------------------------------------:|</div><div class="line">|unit  |`()`   |like &#39;void&#39; in C, a trivial type with just one value|</div><div class="line">|bool  |`false`|either true or false                                |</div><div class="line">|char  |`&#39;c&#39;`  |a single character of text                          |</div><div class="line">|byte  |`0Xff` |a single byte (0-255)                               |</div><div class="line">|short |`42S`  |a 2-byte number                                     |</div><div class="line">|int   |`42`   |a 4-byte number                                     |</div><div class="line">|long  |`42L`  |an 8-byte number                                    |</div><div class="line">|float |`42.0f`|a 4-byte floating point value                       |</div><div class="line">|double|`42.0` |an 8-byte floating point value                      |</div><div class="line"></div><div class="line">These primitives can be combined with arrays:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>[1, 2, 3] </p>
</blockquote>
<p>[1, 2, 3] </p><blockquote class="doxtable">
<p>"foobar" </p>
</blockquote>
<p>"foobar" </p><blockquote class="doxtable">
<p>0xdeadbeef </p>
</blockquote>
<p>0xdeadbeef </p><div class="fragment"><div class="line">They can also be combined with records/tuples:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>{name="Jimmy", age=45, job="programmer"} </p>
</blockquote>
<p>{name="Jimmy", age=45, job="programmer"} </p><blockquote class="doxtable">
<p>("Jimmy", 45, "programmer") </p>
</blockquote>
<p>("Jimmy", 45, "programmer") </p><div class="fragment"><div class="line">Or with arrays of records/tuples, where they will print conveniently as a table:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>[{name="Jimmy", age=45, job="programmer"}, {name="Chicken", age=40, job="programmer"}] </p>
</blockquote>
<p>name age job </p><hr/>
<p> Jimmy 45 programmer Chicken 40 programmer </p><blockquote class="doxtable">
<p>[("Jimmy", 45, "programmer"),("Chicken", 40, "programmer")] </p>
</blockquote>
<p>Jimmy 45 programmer Chicken 40 programmer </p><div class="fragment"><div class="line">We can combine types with variants or sums (the &quot;nameless&quot; form of variants, as tuples are to records).  Because &quot;naked&quot; variant introduction is incomplete by definition, we may sometimes need to introduce explicit type annotations:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>|food="pizza"|::|vehicle:int,food:[char]| </p>
</blockquote>
<p>|food="pizza"| </p><blockquote class="doxtable">
<p>|1="pizza"|::(int+[char]) </p>
</blockquote>
<p>|1="pizza"| </p><div class="fragment"><div class="line">Also, variants can be combined with [isorecursive types](https://en.wikipedia.org/wiki/Recursive_data_type#Isorecursive_types) to make linked lists.  These have a convenient form when printed, and built-in functions to avoid the recursive and variant type boilerplate:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>roll(|1=("chicken", roll(|1=("hot dog", roll(|1=("pizza", roll(|0=()|))|))|))|) :: ^x.(()+([char]*x)) </p>
</blockquote>
<p>"chicken":"hot dog":"pizza":[] </p><blockquote class="doxtable">
<p>cons("chicken", cons("hot dog", cons("pizza", nil()))) </p>
</blockquote>
<p>"chicken":"hot dog":"pizza":[] </p><div class="fragment"><div class="line">These types and type constructors together make up the &quot;algebraic data types&quot; common in the ML family of programming languages (SML, ocaml, Haskell, ...).  The syntax and names for these types also come from ML and common academic programming language textbooks as in [TaPL](https://www.cis.upenn.edu/~bcpierce/tapl/) and [PFPL](http://www.cs.cmu.edu/~rwh/pfpl.html).</div><div class="line"></div><div class="line">As in Haskell, hobbes supports a form of _qualified types_ with type classes and even user-defined constraint resolvers (which we will see in more detail later).  Among many other uses, this allows both mixed-type arithmetic and type inference to coexist:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>0X01+2+3.0+4L+5S </p>
</blockquote>
<p>15 </p><blockquote class="doxtable">
<p>( y z u v.x+y+z+u+v)(0X01,2,3S,4L,5.0) </p>
</blockquote>
<p>15 </p><div class="fragment"><div class="line">We can also use the `hi` program (a slightly more complex interpreter than the example earlier, distributed with hobbes) to evaluate expressions like this and also inspect their types.  For example, the types for the primitive expressions we considered earlier can be queried:</div></div><!-- fragment --><p> $ hi hi : an interactive shell for hobbes type ':h' for help on commands</p>
<blockquote class="doxtable">
<p>:t () </p>
</blockquote>
<p>() </p><blockquote class="doxtable">
<p>:t false </p>
</blockquote>
<p>bool </p><blockquote class="doxtable">
<p>:t 'c' </p>
</blockquote>
<p>char </p><blockquote class="doxtable">
<p>:t 0Xff </p>
</blockquote>
<p>byte </p><blockquote class="doxtable">
<p>:t 42S </p>
</blockquote>
<p>short </p><blockquote class="doxtable">
<p>:t 42 </p>
</blockquote>
<p>int </p><blockquote class="doxtable">
<p>:t 42L </p>
</blockquote>
<p>long </p><blockquote class="doxtable">
<p>:t 42.0f </p>
</blockquote>
<p>float </p><blockquote class="doxtable">
<p>:t 42.0 </p>
</blockquote>
<p>double </p><div class="fragment"><div class="line">And the types for record, array, variant and recursive values:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>:t [1..10] </p>
</blockquote>
<p>[int] </p><blockquote class="doxtable">
<p>:t "foobar" </p>
</blockquote>
<p>[char] </p><blockquote class="doxtable">
<p>:t 0xdeadbeef </p>
</blockquote>
<p>[byte] </p><blockquote class="doxtable">
<p>:t {name="Jimmy", age=45, job="programmer"} </p>
</blockquote>
<p>{ name:[char], age:int, job:[char] } </p><blockquote class="doxtable">
<p>:t ("Jimmy", 45, "programmer") </p>
</blockquote>
<p>([char] * int * [char]) </p><blockquote class="doxtable">
<p>:t cons("foo",nil()) </p>
</blockquote>
<p>^x.(() + ([char] * x)) </p><div class="fragment"><div class="line">Also for qualified types, we can use this feature to view the set of open/unresolved type constraints:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>:t .x.foo </p>
</blockquote>
<p>(a.foo::b) =&gt; (a) -&gt; b </p><blockquote class="doxtable">
<p>:t .foo </p>
</blockquote>
<p>(a.foo::b) =&gt; (a) -&gt; b </p><div class="fragment"><div class="line">Here we see that the type of a simple function which just returns the value of the &quot;foo&quot; field in its input (both in the fully explicit `\x.x.foo` form as well as the equivalent `.foo` shorthand) has a _constraint_ (the part to the left of the `=&gt;` in its type -- the same as in Haskell).  In this case, the entire type states that if a type `a` has a field named `foo` with type `b`, the function has type `a -&gt; b`.  The additional complexity of this constraint allows this function to work with _any_ type `a` meeting that condition.  This particular constraint allows a kind of [duck typing](https://en.wikipedia.org/wiki/Duck_typing) for functions.</div><div class="line"></div><div class="line">## Binding</div><div class="line"></div><div class="line">If we&#39;re using hobbes inside of a C++ process (as opposed to just running scripts with `hi`), at some point we will need to _bind_ C++ values (typically functions) to a `hobbes::cc` instance so that they can be used in dynamic expressions at a later stage.  Much of this work is automated, often allowing us to avoid thinking about binding logic.</div><div class="line"></div><div class="line">For example, consider a C++ function that we might have already defined:</div></div><!-- fragment --><p> int applyDiscreteWeighting(int x, int y) { return x * y; } </p><div class="fragment"><div class="line">Now we can import this definition into our previous program, and bind it to our `hobbes::cc` instance by adding this line:</div></div><!-- fragment --><p> c.bind("applyDiscreteWeighting", &amp;applyDiscreteWeighting); </p><div class="fragment"><div class="line">Then when we run our program, its shell will allow use of this function and will reject any expression using it in a way inconsistent with its type structure:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>applyDiscreteWeighting(3, 4) </p>
</blockquote>
<p>12 </p><blockquote class="doxtable">
<p>applyDiscreteWeighting(3, "pizza") </p>
</blockquote>
<p>*** stdin:1,1-22: Cannot unify types: int != [char] </p><div class="fragment"><div class="line">In other cases, it may be more convenient to use a type understood natively by hobbes and with dynamic memory allocation:</div></div><!-- fragment --><p> typedef std::pair&lt;size_t, const hobbes::array&lt;char&gt;*&gt; MyRecord;</p>
<p>const hobbes::array&lt;MyRecord&gt;* loadRecords(int key) { static const char* names[] = { "chicken", "hot dog", "foobar", "jimmy" };</p>
<p>auto rs = hobbes::makeArray&lt;MyRecord&gt;(key); for (size_t i = 0; i &lt; rs-&gt;size; ++i) { rs-&gt;data[i].first = i; rs-&gt;data[i].second = hobbes::makeString(names[i % 4]); }</p>
<p>return rs; } // [...] c.bind("loadRecords", &amp;loadRecords); // [...] </p><div class="fragment"><div class="line">These calls to `hobbes::makeArray` and `hobbes::makeString` will allocate out of the calling thread&#39;s memory region and will produce data that hobbes knows how to generically destructure and print in a convenient form, as we can see by running this in our test program again:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>loadRecords(10) </p>
</blockquote>
<p>0 chicken 1 hot dog 2 foobar 3 jimmy 4 chicken 5 hot dog 6 foobar 7 jimmy 8 chicken 9 hot dog </p><div class="fragment"><div class="line">If we&#39;d prefer to represent records by structs with significant field names rather than as tuples, we can instead define our type with the `DEFINE_STRUCT` macro (this is purely a syntactic difference -- the final runtime representation of tuples and structs is identical in hobbes).  For example, if we&#39;d defined the `MyRecord` type in the previous example this way:</div></div><!-- fragment --><p> DEFINE_STRUCT(MyRecord, (size_t, index), (const hobbes::array&lt;char&gt;*, name) ); </p><div class="fragment"><div class="line">And change the initialization code in `loadRecords` to refer to these fields by name:</div></div><!-- fragment --><p> // [...] rs-&gt;data[i].index = i; rs-&gt;data[i].name = hobbes::makeString(names[i % 4]); // [...] </p><div class="fragment"><div class="line">Then we can access those fields by name from hobbes and e.g. tables of such records will be printed with a header showing these field names:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>loadRecords(10) </p>
</blockquote>
<p>index name </p><hr/>
<p> 0 chicken 1 hot dog 2 foobar 3 jimmy 4 chicken 5 hot dog 6 foobar 7 jimmy 8 chicken 9 hot dog </p><div class="fragment"><div class="line">We can also bind &quot;in reverse&quot; using C function types, so that rather than making our C++ code appear to be valid hobbes symbols, we can make hobbes expressions appear to be valid C++ symbols.  For example, consider a C++ binding like:</div></div><!-- fragment --><p> int iter2(int (*pf)(int,int), int x) { return pf(pf(x, x), pf(x, x)); } // [...] c.bind("iter2", &amp;iter2); // [...] </p><div class="fragment"><div class="line">Here we&#39;ve bound a function that itself takes a function as input, and we can use the hobbes syntax for anonymous functions to decide logic that this C++ function will use:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>iter2( y.x*x+y, 2) </p>
</blockquote>
<p>42 </p><div class="fragment"><div class="line">Variants can be passed between C++ and hobbes as the `hobbes::variant&lt;...&gt;` type:</div></div><!-- fragment --><p> typedef hobbes::variant&lt;int, const hobbes::array&lt;char&gt;*&gt; classification;</p>
<p>const classification* classifyParameter(int x) { if (x &lt; 42) { return hobbes::make&lt;classification&gt;(42 - x); } else { return hobbes::make&lt;classification&gt;(hobbes::makeString("achievement unlocked")); } } // [...] c.bind("classifyParameter", &amp;classifyParameter); // [...] </p><div class="fragment"><div class="line">These should also print in a standard way (showing the constructor name &quot;0&quot; for the first case and &quot;1&quot; for the second case, since the constructors for this variant have no names), assuming that the payload types of your variant can be printed:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>classifyParameter(16) </p>
</blockquote>
<p>|0=26| </p><blockquote class="doxtable">
<p>classifyParameter(8675309) </p>
</blockquote>
<p>|1="achievement unlocked"| </p><div class="fragment"><div class="line">In the process of binding application variables and functions to a `hobbes::cc` instance, hobbes will decide how to &quot;lift&quot; every C++ type to an equivalent hobbes type.  Many common cases are already handled transparently, as above where types like `size_t` and `std::pair` and `hobbes::array` are &quot;lifted&quot; without any special work required on our part.  If hobbes doesn&#39;t know how to lift a type, it will be lifted as an &quot;opaque C++ type&quot; such that hobbes just checks for consistent usage (and will respect class hierarchies and derived/base conversions as necessary) but will otherwise know nothing about the structure of the type.</div><div class="line"></div><div class="line">For example, consider a binding case like this (meant to represent a complex type hierarchy):</div></div><!-- fragment --><p> class Top { public: Top(int x, double y, int z) : x(x), y(y), z(z) { }</p>
<p>int getX() const { return this-&gt;x; } double getY() const { return this-&gt;y; } int getZ() const { return this-&gt;z; } private: int x; double y; int z; };</p>
<p>class Left : public virtual Top { public: Left(int x, double y, int z) : Top(x, y, z) { } };</p>
<p>class Right : public virtual Top { public: Right(int x, double y, int z) : Top(x, y, z) { } };</p>
<p>class Bottom : public Left, public Right { public: Bottom(int x, double y, int z) : Left(x*z, y*y, z*x), Right(x*x, y*y, z*z), Top(x, y, z) { } }; // [...] c.bind("getX", memberfn(&amp;Top::getX)); c.bind("getY", memberfn(&amp;Top::getY)); c.bind("getZ", memberfn(&amp;Top::getZ));</p>
<p>static Bottom b(1, 3.14159, 42); c.bind("b", &amp;b); // [...] </p><div class="fragment"><div class="line">Now back in our shell, we can invoke the bound `Top` methods on our bound `Bottom` instance (hobbes will coordinate with gcc to apply the correct pointer adjustments):</div></div><!-- fragment --> <blockquote class="doxtable">
<p>b.getX() </p>
</blockquote>
<p>1 </p><blockquote class="doxtable">
<p>b.getY() </p>
</blockquote>
<p>3.14159 </p><blockquote class="doxtable">
<p>b.getZ() </p>
</blockquote>
<p>42 </p><div class="fragment"><div class="line">If the default logic for lifting your C++ type is insufficient, the `hobbes::lift&lt;T&gt;` type can be specialized to determine a more useful description (the code in `hobbes/lang/tylift.H` has many examples of this; this is where the default set of lift definitions are made).</div><div class="line"></div><div class="line">## Storage &lt;a name=&quot;storage&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">Rather than using hobbes to &quot;pull&quot; application data with ad-hoc dynamic queries, we can also use hobbes to &quot;push&quot; large volumes of application data to local or remote storage for real-time or historical analysis.  In this case, we don&#39;t need a compiler instance but instead just need to define some basic quality-of-service parameters for the storage process.  For example, let&#39;s consider a simple mock weather monitor:</div></div><!-- fragment --><p> #include &lt;hobbes/storage.H&gt; #include &lt;stdlib.h&gt;</p>
<p>DEFINE_STORAGE_GROUP( WeatherMonitor, /* an arbitrary name for our data set */ 3000, /* our maximum expected throughput in system pages (if we record up to this limit, we either drop or block) */ hobbes::storage::Unreliable, /* we'd rather drop than block */ hobbes::storage::AutoCommit /* we don't need to correlate multiple records in a batch (non-transactional) */ );</p>
<p>// a set of sensor readings DEFINE_HSTORE_STRUCT( Sensor, (double, temp), (double, humidity) );</p>
<p>int <a class="el" href="build_2CMakeFiles_23_87_82_2CompilerIdC_2CMakeCCompilerId_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a> { while (true) { // record a random sensor reading from somewhere const char* locations[] = { "AZ", "CO", "HI" }; const char* location = locations[rand() % 3];</p>
<p>Sensor s; s.temp = 1.0 + 50.0 * ((double)(rand() % 100)) / 100.0; s.humidity = ((double)(rand() % 100)) / 100.0;</p>
<p>HSTORE(WeatherMonitor, sensor, location, s);</p>
<p>// sometimes record a passing car if (rand() % 100 == 0) { HSTORE(WeatherMonitor, carPassed, location); } } return 0; } </p><div class="fragment"><div class="line">We first use `DEFINE_STORAGE_GROUP` to decide a name for the set of data we&#39;ll record (the name we&#39;ve chosen will be important later), how many memory pages to allocate for the ring buffer where data is temporarily stored (on most systems a page will be 4KB), whether to wait or discard data when it can&#39;t be stored as quickly as we&#39;re producing it, and whether we need to correlate data in batches/transactions or not.</div><div class="line"></div><div class="line">Then we use `DEFINE_HSTORE_STRUCT` to define a simple `Sensor` structure.</div><div class="line"></div><div class="line">Finally we run a simple loop, generating and recording mock sensor data.  The `HSTORE` macro, which we use to record data, takes the name of our storage group, an arbitrary name to identify this data, and then any subsequent arguments as data to store.  If our storage group is used in &quot;unreliable&quot; mode (as in the above example), then the `HSTORE` macro will return `false` if the data was dropped due to a consumer falling behind.  Many common types can be stored automatically with `HSTORE` (primitives, `std::string`, `std::vector`, ...) and as with binding to C++ symbols, it is possible to define storage for custom types by specializing the `hobbes::storage::store&lt;T&gt;` type (here the definitions in `hobbes/storage.H` can be instructive).</div><div class="line"></div><div class="line">Now, at the same time that this program runs, we will also want to run another program to consume this data.  The `hog` program is distributed with hobbes for this purpose -- its source code may be instructive if you&#39;d like to understand the storage consumer API or customize its logic in some way.  To get an overview of our recording options with this program, we can run it without arguments:</div></div><!-- fragment --><p> $ hog hog : record structured data locally or to a remote process</p>
<p>usage: hog [-d &lt;dir&gt;] [-g group+] [-p t s host:port] [-s port] where -d &lt;dir&gt; : decides where structured data (or temporary data) is stored -g group+ : decides which data to record from memory on this machine -p t s host:port : decides to send data to a remote process every t time units or every s uncompressed bytes written -s port : decides to receive data on the given port $ </p><div class="fragment"><div class="line">This shows that we can use this program to consume and store data in one of three modes:</div><div class="line"></div><div class="line">1. immediate storage into a local disk file</div><div class="line">2. temporary local storage (batched, compressed) pending successful sends to a remote process</div><div class="line">3. a network server, storing into local files from remote processes</div><div class="line"></div><div class="line">For our test program above, it will be enough to just store data locally.  We can start the producer (our test program above) or the consumer in any order.  Let&#39;s assume that the test program is already running, then we can run `hog` like this to begin recording data:</div></div><!-- fragment --><p> $ hog -g WeatherMonitor [2017-01-01T09:00:00.867323]: hog running in mode : |local={ dir="./", groups={"WeatherMonitor"} }| [2017-01-01T09:00:00.867536]: polling for creation of memory regions</p>
<p>[2017-01-01T09:00:01.637614]: ==&gt; carPassed :: ([char]) (#1) [2017-01-01T09:00:01.733374]: ==&gt; sensor :: ([char] * { temp:double, humidity:double }) (#0) [2017-01-01T09:00:01.848340]: finished preparing statements, writing data to './WeatherMonitor/data-2017.01.01-0.log' </p><div class="fragment"><div class="line">Now while these two programs (both `hog` and our test program) are left running, we can simultaneously run a third program to load and query this data as it is being recorded.  This is a good use-case for the `hi` program seen previously.  If we enter the same directory where `hog` is running, we can take a look at the data we&#39;re recording this way:</div></div><!-- fragment --><p> $ hi hi : an interactive shell for hobbes type ':h' for help on commands</p>
<blockquote class="doxtable">
<p>wm = inputFile :: (LoadFile "./WeatherMonitor/data-2017.01.01-0.log" w) =&gt; w wm.sensor </p>
</blockquote>
<p>AZ {temp=44.572017, humidity=44.582017} AZ {temp=3.575808, humidity=3.585808} HI {temp=39.150116, humidity=39.160116} ... </p><blockquote class="doxtable">
<p>wm.carPassed </p>
</blockquote>
<p>AZ AZ CO AZ ... </p><blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">Although the syntax for loading this file may appear somewhat unusual (or maybe not, after we&#39;ve covered qualified types and type classes in more detail), this method of loading data in `hi` should let us look at what we&#39;re recording fairly quickly.  If we repeatedly query the same data while it&#39;s being written, we should see different results as our view of the data is &quot;live&quot;.  It&#39;s also possible to &quot;tail&quot; specific data as it is written by registering a function to handle updates:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>signals(wm).sensor &lt;- (_.do { putStrLn("sensor batch updated"); return true }) sensor batch updated </p>
</blockquote>
<p>sensor batch updated sensor batch updated sensor batch updated </p><div class="fragment"><div class="line">In more complex applications, we might use this ability to accumulate statistics, index recorded data, alert on some condition, etc.</div><div class="line"></div><div class="line">We could also want to record batched or &quot;transactional&quot; data where our storage statements need to be correlated.  For example, consider a mock cheeseburger order management application:</div></div><!-- fragment --><p> #include &lt;hobbes/storage.H&gt; #include &lt;stdlib.h&gt;</p>
<p>DEFINE_STORAGE_GROUP( Orders, 3000, hobbes::storage::Reliable, /* we <em>must</em> track all orders */ hobbes::storage::ManualCommit /* we need to correlate all events in an order */ );</p>
<p>int <a class="el" href="build_2CMakeFiles_23_87_82_2CompilerIdC_2CMakeCCompilerId_8c.html#a0ddf1224851353fc92bfbff6f499fa97">main()</a> { while (true) { // a customer enters the store const char* names[] = { "Harv", "Beatrice", "Pat" }; const char* name = names[rand() % 3];</p>
<p>HSTORE(Orders, customerEntered, name);</p>
<p>// he/she orders a cheeseburger const char* products[] = { "BBQ Attack", "Cheese Quake", "Bacon Salad" }; const char* product = products[rand() % 3];</p>
<p>HSTORE(Orders, productOrdered, product);</p>
<p>// perhaps he/she decides to add a drink if (rand() % 5 == 0) { const char* drinks[] = { "Soda", "Lemonade", "Water" }; const char* drink = drinks[rand() % 3];</p>
<p>HSTORE(Orders, drinkOrdered, drink); }</p>
<p>// sometimes the customer has a change of heart, else they pay up and go if (rand() % 10 == 0) { HSTORE(Orders, orderCanceled); } else { HSTORE(Orders, paymentReceived, 10.0 * ((double)(rand() % 100)) / 100.0); }</p>
<p>// now that the order is finished, end the transaction Orders.commit(); } return 0; } </p><div class="fragment"><div class="line">Now that we have indicated that we&#39;re recording meaningful transactions, when we run `hog` for this storage group, it will also record a &quot;transactions&quot; sequence along with the sequences it logs for each storage statement:</div></div><!-- fragment --><p> $ hog -g Orders [2017-01-01T09:00:00.371394]: hog running in mode : |local={ dir="./", groups={"Orders"} }| [2017-01-01T09:00:00.371633]: polling for creation of memory regions</p>
<p>[2017-01-01T09:00:01.615395]: ==&gt; paymentReceived :: (double) (#4) [2017-01-01T09:00:01.736183]: ==&gt; orderCanceled :: () (#3) [2017-01-01T09:00:01.753279]: ==&gt; drinkOrdered :: ([char]) (#2) [2017-01-01T09:00:01.838780]: ==&gt; productOrdered :: ([char]) (#1) [2017-01-01T09:00:01.880418]: ==&gt; customerEntered :: ([char]) (#0) [2017-01-01T09:00:01.927219]: ==&gt; transactions :: &lt;any of="" the="" above&gt;=""&gt; [2017-01-01T09:00:02.136798]: finished preparing statements, writing data to './Orders/data-2017.01.01-0.log' </p><div class="fragment"><div class="line">And if we simultaneously load this file, we can see that all of our storage statements can be queried as well as this new &quot;transactions&quot; data.  Each transaction is stored as a timestamp and an array of a variant over all possible storage statements so that we can tell which statements were recorded and in what order:</div></div><!-- fragment --><p> $ hi hi : an interactive shell for hobbes type ':h' for help on commands</p>
<blockquote class="doxtable">
<p>orders = inputFile :: (LoadFile "./Orders/data-2017.01.01-0.log" w) =&gt; w orders.transactions </p>
</blockquote>
<p>time entries </p><hr/>
<p> 2017-04-11T12:19:03.244206 [|customerEntered=("Pat")|, |productOrdered=("Bacon Salad")|, |orderCanceled|] 2017-04-11T12:19:03.244172 [|customerEntered=("Beatrice")|, |productOrdered=("Cheese Quake")|, |orderCanceled|] 2017-04-11T12:19:03.244127 [|customerEntered=("Pat")|, |productOrdered=("Cheese Quake")|, |drinkOrdered=("Water")|, |paymentReceived=(6.4)|] 2017-04-11T12:19:03.244092 [|customerEntered=("Pat")|, |productOrdered=("Bacon Salad")|, |paymentReceived=(6.4)|] 2017-04-11T12:19:03.244047 [|customerEntered=("Pat")|, |productOrdered=("Cheese Quake")|, |drinkOrdered=("Lemonade")|, |paymentReceived=(2.1)|] 2017-04-11T12:19:03.244013 [|customerEntered=("Pat")|, |productOrdered=("Bacon Salad")|, |paymentReceived=(7.6)|] 2017-04-11T12:19:03.243978 [|customerEntered=("Beatrice")|, |productOrdered=("BBQ Attack")|, |paymentReceived=(3.4)|] 2017-04-11T12:19:03.243944 [|customerEntered=("Beatrice")|, |productOrdered=("Bacon Salad")|, |paymentReceived=(3.5)|] 2017-04-11T12:19:03.243910 [|customerEntered=("Harv")|, |productOrdered=("Cheese Quake")|, |paymentReceived=(6.3)|] ... </p><div class="fragment"><div class="line">Although the content of these transactions appears to possibly be very large, it&#39;s actually just a minor addition due to the way that this data is stored.  It can also be queried very efficiently.</div><div class="line"></div><div class="line">## Networking &lt;a name=&quot;networking&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">Just as we may need a lightweight, efficient method to record structured application data from C++, we may also need such a method to efficiently query plain C++ data from a remote process that understands hobbes.  This is made possible with a macro `DEFINE_NET_CLIENT` that takes a _signature_ for interaction and produces a type to implement it.</div><div class="line"></div><div class="line">We can cut to the chase with a simple test program:</div></div><!-- fragment --><p> #include &lt;iostream&gt; #include &lt;hobbes/net.H&gt;</p>
<p>// our RPC signature DEFINE_NET_CLIENT( Connection, // a name for this connection profile (add, int(int,int), "\\x y.x+y"), // a function "add" of type int(int,int) remotely implemented by the expression ' y.x+y' (mul, int(int,int), "\\x y.x*y") // as above but "mul" for the expression ' y.x*y' );</p>
<p>int <a class="el" href="CMakeFiles_2feature__tests_8cxx.html#a3c04138a5bfe5d72780bb7e82a18e627">main(int, char**)</a> { try { Connection c("localhost:8080");</p>
<p>std::cout &lt;&lt; "c.add(1,2) = " &lt;&lt; c.add(1,2) &lt;&lt; std::endl &lt;&lt; "c.mul(1,2) = " &lt;&lt; c.mul(1,2) &lt;&lt; std::endl;</p>
<p>} catch (std::exception&amp; e) { std::cout &lt;&lt; "*** " &lt;&lt; e.what() &lt;&lt; std::endl; } return 0; } </p><div class="fragment"><div class="line">Here we assume that a process is running at `localhost:8080` to accept our requests.  Once the connection is made, we initialize the remote end with our expected expressions/types (so that we can efficiently invoke them later just by ID).  If any part of this process fails (connection or remote type-checking) then an exception will be raised describing the failure.  Otherwise, execution proceeds in this case just to call both functions and report the results.</div><div class="line"></div><div class="line">We can run a `hi` process to quietly listen on port 8080 like this:</div></div><!-- fragment --><p> $ hi -s -p 8080 </p><blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">And if we&#39;ve compiled our test program above to an executable named `test` then we can invoke and run it against our running server to observe results like:</div></div><!-- fragment --><p> $ ./test c.add(1,2) = 3 c.mul(1,2) = 2 $ </p><div class="fragment"><div class="line">Just as lightweight storage definitions can be added by specializing `hobbes::storage::store&lt;T&gt;`, also lightweight RPC codecs can be added by specializing `hobbes::net::io&lt;T&gt;` (and many types and type families are supported in `hobbes/net.H`, for example).</div><div class="line"></div><div class="line">This networking/remote-evaluation method can be accessed purely from hobbes as well.  For example, with the previous `hi` server process still running, we can start a new `hi` process to talk to it like this:</div></div><!-- fragment --><p> $ hi -s </p><blockquote class="doxtable">
<p>c = connection :: (Connect "localhost:8080" p) =&gt; p</p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">Now we have a connection made _at compile-time_.  We can determine the (current) static structure of this connection with the `printConnection` function, which currently shows this:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>printConnection(c) </p>
</blockquote>
<p>localhost:8080</p>
<p>id expr input output </p><hr/>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">Now we can make a basic function to perform some interaction between these processes.  Say we want a function to record a set of data about employees:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>sendData = .receive(invoke(c, <code>\x.println(x)</code>, x :: [{name:[char], age:int, salary:double}])) </p>
</blockquote>
<blockquote class="doxtable">
<p>:t sendData </p>
</blockquote>
<p>([{ name:[char], age:int, salary:double }]) -&gt; () </p><div class="fragment"><div class="line">Here we see a couple of new functions, `invoke` and `receive` to perform remote evaluation and parse results (respectively).  We haven&#39;t invoked `sendData` yet, but because we have kept this connection at compile-time, `hi` was able to communicate with the remote process enough to know what its result type will be (though we&#39;ve only specified the input type), and if we try `printConnection` again we should see this static protocol detail that&#39;s been negotiated:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>printConnection(c) </p>
</blockquote>
<p>localhost:8080</p>
<p>id expr input output </p><hr/>
<p> 0 (.arg0).(let .t13409.rv0 = .arg0 in println(.t13409.rv0)) [{ name:[char], age:int, salary:double }] () </p><div class="fragment"><div class="line">This shows that the remote (desugared) expression is known statically, as well as input and output types, and a unique ID has been determined for the expression.  At a later stage (&quot;run-time&quot; or &quot;on the critical path&quot;), to invoke this remote expression our sender program just has to write this value `0` followed by the input data that the remote side expects for this particular expression (but no further &quot;self-describing&quot; data).</div><div class="line"></div><div class="line">This also critically relies on a feature of our type representation in hobbes, that it can carry statically-known expressions.  In this example, we use a &quot;quoted expression&quot; form to carry this expression so that it can be used at compile-time:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>:t <code>\x.println(x)</code> </p>
</blockquote>
<p>(quote (.arg0).(let .t14200.rv0 = .arg0 in println(.t14200.rv0))) </p><div class="fragment"><div class="line">This type is equivalent to `()` at run-time (i.e.: it doesn&#39;t exist at run-time), but carrying its quoted expression in this way we can reason about and send/receive expression details at compile-time.</div><div class="line"></div><div class="line">And if we invoke the function we&#39;ve defined:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>sendData([{name="bob", age=40, salary=23.2}, {name="jane", age=51, salary=53.1}]) </p>
</blockquote>
<div class="fragment"><div class="line">The remote side will print it, as expected:</div></div><!-- fragment --><p> name age salary </p><hr/>
<p> bob 40 23.2 jane 51 53.1 </p><div class="fragment"><div class="line">## Comprehensions &lt;a name=&quot;comprehensions&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">Whether we are running queries directly against application bindings, against out-of-band live/historical data, or as prepared remote queries, we will eventually need to sort, join, group, filter, and transform data.  Traditionally we might think of SQL queries for problems like this, but hobbes (inspired as it is by Haskell) uses [comprehensions](https://en.wikipedia.org/wiki/List_comprehension) and basic functions.</div><div class="line"></div><div class="line">A comprehension has the general form:</div></div><!-- fragment --><p> [E | p &lt;- S, C] </p><div class="fragment"><div class="line">Where `E` is a _transform_ or _map_ expression, `S` is an expression producing a sequence (of some type), `p` is a _pattern_ matched against each value in `S` (possibly introducing variables used in `E`), and `C` is a boolean _filter expression_ that decides which values in `S` to select.  The `C` expression is optional and may be omitted.  The pattern `p` is usually just a name for a variable, but can be more complex if necessary.</div><div class="line"></div><div class="line">For example, we might want string representations of numbers evenly divisible by 3, out of the first 20 natural numbers:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>[show(x) | x &lt;- [0..20], x % 3 == 0] </p>
</blockquote>
<p>["0", "3", "6", "9", "12", "15", "18"] </p><div class="fragment"><div class="line">If we&#39;ve loaded the storage file from our mock weather monitor example earlier, we might want to get readings for AZ:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>[p.1 | p &lt;- wm.sensor, p.0 == "AZ"] </p>
</blockquote>
<p>temp humidity </p><hr/>
<p> 12.5 12.51 33 33.01 16 16.01 48 48.01 5.5 5.51 ... </p><div class="fragment"><div class="line">Alternately, we could use pattern binding both to simplify tuple indexing and to do the equality check (any values that don&#39;t match our pattern will be excluded):</div></div><!-- fragment --> <blockquote class="doxtable">
<p>[s | ("AZ", s) &lt;- wm.sensor] </p>
</blockquote>
<p>temp humidity </p><hr/>
<p> 12.5 12.51 33 33.01 16 16.01 48 48.01 5.5 5.51 ... </p><div class="fragment"><div class="line">We can use the function `groupBy` to categorize a sequence, and then use a comprehension with the result to summarize it:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>[(k, sum(vs)) | (k, vs) &lt;- groupBy(.x % 3, [0..20])] </p>
</blockquote>
<p>0 63 1 70 2 77 </p><div class="fragment"><div class="line">We can use the function `joinBy` to combine two sequences of values on a common key:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>joinBy(.name, [{name="bob", score=20}, {name="jim", score=50}], .id, [{id="jim", age=6}, {id="bob", age=42}]) </p>
</blockquote>
<p>name score id age </p><hr/>
<p> bob 20 bob 42 jim 50 jim 6 </p><div class="fragment"><div class="line">We can also use a _slice notation_ to select subsequences.  The syntax `S[i:e]` can be used to select values out of `S` starting at `i` and ending at `e`.  Both `i` and `e` are interpreted as indexes in the sequence but can be empty to indicate the end of sequence or negative to indicate an offset from the end of the sequence.  Indexes that are out of bounds will not be included in the result.  If `i` is greater than `e` then the result will be reversed compared to its original order in `S`.  Let&#39;s try a few examples:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>"foobar"[0:3] </p>
</blockquote>
<p>"foo" </p><blockquote class="doxtable">
<p>"foobar"[3:0] </p>
</blockquote>
<p>"oof" </p><blockquote class="doxtable">
<p>"foobar"[-3:] </p>
</blockquote>
<p>"bar" </p><blockquote class="doxtable">
<p>"foobar"[:-3] </p>
</blockquote>
<p>"rab" </p><blockquote class="doxtable">
<p>"foobar"[0:] </p>
</blockquote>
<p>"foobar" </p><blockquote class="doxtable">
<p>"foobar"[:0] </p>
</blockquote>
<p>"raboof" </p><div class="fragment"><div class="line">We can sort a sequence with the `sort` or `sortWith` functions, assuming that either the sequence type is orderable or we can provide a function on values in the sequence to a type that&#39;s orderable.  Values will be given in ascending order, but we can get descending order just by reversing this sequence:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>sort([0..10]) </p>
</blockquote>
<p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </p><blockquote class="doxtable">
<p>sortWith(.age, [{name="jimmy", age=30, state="AZ"}, {name="bob", age=42, state="CO"}, {name="frank", age=37, state="HI"}]) </p>
</blockquote>
<p>name age state </p><hr/>
<p> jimmy 30 AZ frank 37 HI bob 42 CO </p><blockquote class="doxtable">
<p>sortWith(.age, [{name="jimmy", age=30, state="AZ"}, {name="bob", age=42, state="CO"}, {name="frank", age=37, state="HI"}])[:0] </p>
</blockquote>
<p>name age state </p><hr/>
<p> bob 42 CO frank 37 HI jimmy 30 AZ </p><div class="fragment"><div class="line">Together, these methods of consuming sequences can be especially useful to inspect the state of a hobbes-enabled process or to analyze recorded application data.</div><div class="line"></div><div class="line">## Pattern Matching &lt;a name=&quot;pat-match&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">The hobbes language supports a form of [pattern matching](http://caml.inria.fr/pub/docs/oreilly-book/html/book-ora016.html) for classifying and destructuring data.  The most general form of pattern matching is in the _match expression_, and we will consider how other uses of matching, like in sequence comprehensions, can be rewritten (or &quot;desugared&quot;) into this general form.</div><div class="line"></div><div class="line">An important special case of match expressions are C++ `switch` statements, as the C++ code:</div></div><!-- fragment --><p> switch (x) { case 0: return "foo"; case 1: return "bar"; case 2: return "chicken"; default: return "beats me"; } </p><div class="fragment"><div class="line">is equivalent to the hobbes match expression (because the pattern `_` matches any value):</div></div><!-- fragment --><p> match x with | 0 -&gt; "foo" | 1 -&gt; "bar" | 2 -&gt; "chicken" | _ -&gt; "beats me" </p><div class="fragment"><div class="line">And in general, for `r` distinct cases, both will efficiently determine a result in `O(log(r))` time (although some expressions, like the one above, can be arranged to run in `O(1)` time).</div><div class="line"></div><div class="line">But match expressions generalize `switch` statements in a few key ways.</div><div class="line"></div><div class="line">First, match expressions allow you to match on multiple values at once (so that for `c` values and `r` cases, a match can be determined in `O(c*log(r))` time -- in the `switch` example we have `c=1` and the expected time complexity).  For example, we could write a match expression like:</div></div><!-- fragment --><p> match x y with | 0 0 -&gt; "foo" | 0 1 -&gt; "foobar" | 1 0 -&gt; "bar" | 1 1 -&gt; "barbar" | 2 0 -&gt; "chicken" | 2 1 -&gt; "chicken bar!" | _ _ -&gt; "beats me" </p><div class="fragment"><div class="line">where we&#39;d otherwise have to write a `switch` statement like:</div></div><!-- fragment --><p> switch (x) { case 0: switch (y) { case 0: return "foo"; case 1: return "foobar"; default: return "beats me"; } case 1: switch (y) { case 0: return "bar"; case 1: return "barbar"; default: return "beats me"; } case 2: switch (y) { case 0: return "chicken"; case 1: return "chicken bar!"; default: return "beats me"; } default: return "beats me"; } </p><div class="fragment"><div class="line">and although both code fragments will compute the same result in the same amount of time (likely in exactly the same way), the match expression is more concise and so offers some _notational convenience_.</div><div class="line"></div><div class="line">Another way that match expressions generalize `switch` statements is that they allow binding variables to some portion of a matched value.  For example, we might match on a complex variant type like the order transaction entry type from the storage example we looked at earlier:</div></div><!-- fragment --><p> match e with | |paymentReceived=x| -&gt; "received " ++ show(x) | _ -&gt; "something happened" </p><div class="fragment"><div class="line">In this case, the pattern `|paymentReceived=x|` checks that the variant in `e` is the `paymentReceived` case and if so, binds its payload to the variable `x` where it can be used subsequently.  This matching and binding process can be nested to any depth, so for example this expression:</div></div><!-- fragment --><p> match [(1,2),(3,4),(5,6)] with | [_, (3, x), _] -&gt; x | _ -&gt; -1 </p><div class="fragment"><div class="line">will evaluate to `4` because the first pattern row checks for an array of length 3 where the second value is a pair where the first value is `3` and the second value we will bind to `x` (given the input then, `x=4`) and then `x` is immediately returned.</div><div class="line"></div><div class="line">As a special case of this, when we match on character arrays, we can use regular expressions with typical binding syntax as a form of pattern as well.  For example, this expression:</div></div><!-- fragment --><p> match "foobar" with | 'f(?&lt;us&gt;u*)bar' -&gt; us | 'f(?&lt;os&gt;o*)bar' -&gt; os | _ -&gt; "???" </p><div class="fragment"><div class="line">will evaluate to `&quot;oo&quot;` because it matches the second regular expression, which binds to the variable `os` the sub-sequence of the input matching `o*`.</div><div class="line"></div><div class="line">Finally, another way that match expressions generalize `switch` statements is that cases may contain a _guard expression_ which makes the final determination whether or not to follow a branch.  For example, this expression:</div></div><!-- fragment --><p> match 1 2 with | 1 x where x &gt; 10 -&gt; 1 | _ _ -&gt; 2 </p><div class="fragment"><div class="line">will return `2` because, although the input does match the first row at the patterns `1 x`, the _guard expression_ `x &gt; 10` (in this case, `2 &gt; 10`) evaluates to `false` and so the branch for that row is not followed, causing just the final row to match.</div><div class="line"></div><div class="line">In order to be considered valid (and subsequently compiled), match tables must be _exhaustive_ and all rows _reachable_.  To be exhaustive, it just means that there is a matching row for every possible input to the match table (this is why the examples so far always end with a &quot;match any&quot; row like `| _ -&gt; -1`).  For a row to be reachable, it means that no prior row fully subsumes it and so makes it redundant (this check can be disabled with a compiler flag but it is on by default under the assumption that programmers introduce pattern rows because they intend for them to be relevant).  This interpretation of matching is slightly different than in ocaml and Haskell, where e.g. inexhaustive matches may be flagged with a warning and then abort program execution at runtime when some input is given that doesn&#39;t match any row.</div><div class="line"></div><div class="line">The fully general form of match expressions may be written:</div></div><!-- fragment --><p> match I0 I1 ... IN with | p00 p10 ... pN0 where C0 -&gt; E0 | p01 p11 ... pN1 where C1 -&gt; E1 | ... | p0R p1R ... pNR -&gt; ER </p><div class="fragment"><div class="line">such that each of `I0`, `I1`, ..., `IN` is an expression whose value will be matched, each `pij` is a pattern to match against the value `Ii`, `Cr` is a condition to evaluate against the variables in `p0r` to `pNr`, and each `Er` is a result expression to return iff row `r` is selected (by implication, the type of each such `Er` must be the same).</div><div class="line"></div><div class="line">And a pattern is any term freely generated by the grammar:</div></div><!-- fragment --><p> pattern := constant | variable | [pattern, pattern, ..., pattern] | regex | (pattern, pattern, ..., pattern) | {f0=pattern, f1=pattern, ..., fN=pattern} | |C=pattern| </p><div class="fragment"><div class="line">where `constant` is any constant value (`()`, `true`, `42`, `&#39;c&#39;`, etc), `variable` is any name (unique across a row), `f0`, `f1`, ..., `fN` are record field names, and `C` is a variant constructor name.</div><div class="line"></div><div class="line">For convenience, the expression `E matches p` desugars to `match E with | p -&gt; true | _ -&gt; false`.  If the pattern `p` is _irrefutable_ (ie: never fails to match) then `let p = E in B` desugars to `match E with | p -&gt; B`.  If the pattern `p` is irrefutable then `\p.E` desugars to `\x.match x with | p -&gt; E`.  If the pattern `p` is _refutable_ then the expression `\p.E` desugars to `\x.match x with | p -&gt; just(E) | _ -&gt; nothing`.  If the pattern `p` is irrefutable, then `[E | p &lt;- S]` desugars to `map(\p.E, S)`.  If the pattern `p` is refutable, then `[E | p &lt;- S]` desugars to `dropNulls(map(\p.E, S))`.</div><div class="line"></div><div class="line">Pattern matching is very useful in many different kinds of applications.  For some uses of hobbes, it even functions as a kind of &quot;rules engine&quot; (where rows are &quot;rules&quot;) such that users can derive very efficient machine code from very large match tables.</div><div class="line"></div><div class="line">## Parsing &lt;a name=&quot;parsing&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">Although many parsing problems can be solved with match expressions, there are many other common parsing problems for which the approach is insufficient.  In particular, basic expression languages [can&#39;t be parsed](https://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages) by the simple regular expressions supported in match expressions.</div><div class="line"></div><div class="line">For these cases, hobbes defines a syntax for the introduction of parsers based on context-free grammars (technically, we produce [LALR(1) parsers](https://en.wikipedia.org/wiki/LALR_parser)).  As with many such methods (e.g. [yacc](https://en.wikipedia.org/wiki/Yacc), [GNU bison](https://www.gnu.org/software/bison/), [happy](https://www.haskell.org/happy/), ...) parsing rules define both syntax as well as &quot;actions&quot; for producing semantic values out of each rule.</div><div class="line"></div><div class="line">As an example, we can build up to a basic calculator for arithmetic expressions.  Let&#39;s start with the simplest first step, a parser for recognizing single digits:</div></div><!-- fragment --><p> $ cat p.hob</p>
<p>calc = parse { D := "0" {0} | "1" {1} | "2" {2} | "3" {3} | "4" {4} | "5" {5} | "6" {6} | "7" {7} | "8" {8} | "9" {9} }</p>
<div class="fragment"><div class="line">Here we have a file with just a single definition (to define the `calc` variable).  With this definition, we use the syntax `parse { RULES }` to construct a parser based on all of the rules in `RULES` and starting from the first rule in the sequence (in this case, the rule for `D`).  Here our syntax terms are simple (just the constant lexical values as in `&quot;0&quot;`, `&quot;4&quot;`, etc) and the actions are also simple (returning `0`, `4`, etc).  These actions can be arbitrary hobbes code, which will be useful as we develop this parser into something more useful.</div><div class="line"></div><div class="line">For now, if we load this file with the `hi` program, we can first check the type of this new definition:</div></div><!-- fragment --><p> $ hi p.hob hi : an interactive shell for hobbes type ':h' for help on commands</p>
<p>loaded module 'p.hob' </p><blockquote class="doxtable">
<p>:t calc </p>
</blockquote>
<p>Array a char =&gt; (a) -&gt; (() + int) </p><div class="fragment"><div class="line">This tells us that the prepared parser is actually an overloaded function, taking any type that can be interpreted as an array of characters to a &quot;maybe int&quot; (it&#39;s _maybe_ because the parser input might not be recognized).</div><div class="line"></div><div class="line">We can interact with this parser to see its simple behavior:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>calc("9") </p>
</blockquote>
<p>9 </p><blockquote class="doxtable">
<p>calc("42") </p>
</blockquote>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">Now we can see that a string with a single digit _is_ recognized, but trying to read multi-digit input fails to produce a value.  So we can go back to our file `p.hob` and extend the grammar slightly to accept multiple digits:</div></div><!-- fragment --><p> calc = parse { V := v:V d:D { v*10 + d } | d:D { d }</p>
<p>D := "0" {0} | "1" {1} | "2" {2} | "3" {3} | "4" {4} | "5" {5} | "6" {6} | "7" {7} | "8" {8} | "9" {9} } </p><div class="fragment"><div class="line">Here we&#39;ve introduced a few new ideas.  First, the rules for `V` define syntax in terms of the rule `D` (and `V` itself) rather than directly specifying lexical syntax.  Also, the rules for `V` _bind values_ to matched sub-rules (in the variables `v` and `d`) which are available for use in actions for those rules.  Finally, the first rule for `V` uses [left recursion](https://en.wikipedia.org/wiki/Left_recursion) to accept an indefinite-length sequence of lexical digits that will be incrementally translated to a single integer value in the usual way.  We can see this with another interaction:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>calc("42") </p>
</blockquote>
<p>42 </p><blockquote class="doxtable">
<p>calc("8675309") </p>
</blockquote>
<p>8675309 </p><div class="fragment"><div class="line">But nonsensical input (still including input involving arithmetic operators) will be rejected:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>calc("1+2") </p>
</blockquote>
<blockquote class="doxtable">
<p>calc("cheeseburger") </p>
</blockquote>
<blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">Finally, we can add support for arithmetic operators (respecting standard order of operations) by the [typical arithmetic grammar](https://en.wikipedia.org/wiki/Syntax_diagram#Example):</div></div><!-- fragment --><p> calc = parse { E := x:E "+" y:T { x + y } | x:E "-" y:T { x - y } | x:T { x }</p>
<p>T := x:T "*" y:F { x * y } | x:T "/" y:F { x / y } | x:F { x }</p>
<p>F := "(" x:E ")" { x } | x:V { x }</p>
<p>V := v:V d:D { v*10 + d } | d:D { d }</p>
<p>D := "0" {0} | "1" {1} | "2" {2} | "3" {3} | "4" {4} | "5" {5} | "6" {6} | "7" {7} | "8" {8} | "9" {9} } </p><div class="fragment"><div class="line">And we have a parser that can recognize and evaluate simple arithmetic expressions:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>calc("9*(7+(8-4*3)/2)-3") </p>
</blockquote>
<p>42 </p><div class="fragment"><div class="line">Not every syntactically valid parser definition will produce a valid parser.  Some parser definitions introduce _ambiguous choice_ (where the parser must choose between two equally valid paths).  In hobbes, these are treated as errors rather than accepting unpredictable performance (all parse times should be `O(n)` for `n` input characters).</div><div class="line"></div><div class="line">For example, consider a parser definition like this:</div></div><!-- fragment --><p> $ cat e.hob</p>
<p>err = parse { S := "a" { 1 } | z:Z { z }</p>
<p>Z := "a" { 2 } } </p><div class="fragment"><div class="line">Here, parsing the `S` definition must be ambiguous for the input `&quot;a&quot;` because we could either choose the first path through `S := &quot;a&quot;` (giving `1` as the result) or else through `z:Z` we could choose `Z := &quot;a&quot;` (giving `2` as the result).  Because this choice is ambiguous, hobbes will reject the parser with an error indicating where its grammar went wrong:</div></div><!-- fragment --><p> $ hi -s e.hob e.hob:2,7-7,1: Conflict between r0 and r0 on $ S -&gt; 'a'# [$] Z -&gt; 'a'# [$] </p><div class="fragment"><div class="line">In this error message, the symbol `#` is meant to indicate a position in a basic grammar rule (as in [parser items](https://en.wikipedia.org/wiki/Canonical_LR_parser#Parser_items)), and the symbols in brackets indicate the [lookahead](https://en.wikipedia.org/wiki/Parsing#Lookahead) values that allow the parser to conclude that a rule can be completed or _reduced_.  So the error message above is telling us that in the given state, we could either reduce with `S -&gt; &#39;a&#39;#` or `Z -&gt; &#39;a&#39;#` on the end-of-input terminal (aka `$`).</div><div class="line"></div><div class="line">## Type Classes &lt;a name=&quot;type-classes&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">In hobbes, user-defined overloading and ad-hoc type analysis can be defined through the use of [type classes](https://en.wikipedia.org/wiki/Type_class).  Type classes were [originally introduced](https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf) in Haskell as a way to combine overloading and type inference.  They can also be viewed as a specialized use of [qualified types](http://web.cecs.pdx.edu/~mpj/pubs/rev-qual-types.pdf), which is also the view taken in hobbes (although the majority of type constraints in hobbes programs so far designate type classes).  To get the intuition for the idea prior to a formal statement, let&#39;s consider some simple examples.</div><div class="line"></div><div class="line">One of the simplest type classes to consider is the `Show` class, which has the job of converting a value to a string.  In hobbes, `Show` is defined like this:</div></div><!-- fragment --><p> class Show a where show :: a -&gt; [char] </p><div class="fragment"><div class="line">This definition can be read as a statement that the constraint `Show a` is true if and only if there is an associated function `show` of type `a -&gt; [char]`.  We introduce these associated functions with `instance` definitions (also as in Haskell), as in for example:</div></div><!-- fragment --><p> instance Show int where show = showInt </p><div class="fragment"><div class="line">Because there happens to be a function `showInt :: int -&gt; [char]` defined by default with hobbes, it works perfectly as a `show` function for `int` values.  With this definition in place, we can evaluate:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>show(42) </p>
</blockquote>
<p>"42" </p><div class="fragment"><div class="line">But hobbes also supports regular families of types, and although it works well enough for primitive types to define each `Show` instance on a case-by-case basis, it would be very frustrating if we had to do the same thing to show a value of type `[int]` and again to show a value of type `[[int]]` or `[[[int]]]` etc.  We can use _instance generators_ where there is a regular rule to decide how to construct a type class instance for a set of types.  In the case of arrays, for example, we can introduce an instance generator for `Show` like this:</div></div><!-- fragment --><p> instance (Show a) =&gt; Show [a] where show xs = "[" ++ cdelim(map(show, xs), ", ") ++ "]" </p><div class="fragment"><div class="line">This definition appears almost identical to a regular `instance` definition as before, but it has a constraint to the left of the `=&gt;` as in a qualified type.  In this case, a good way to read `(Show a) =&gt; Show [a]` is &quot;if it&#39;s true that there&#39;s a `Show a` instance, then we can make a `Show [a]` instance&quot;.  Then we just introduce a definition of `show` that can work for any such value of type `[a]`.  Because there happens to be a function `cdelim :: ([[char]]*[char]) -&gt; [char]` around to concatenate an array of strings interleaved with another string, it&#39;s pretty easy to write this function so that we show every value in the input array and then join them together into one larger string.</div><div class="line"></div><div class="line">Experimenting at the prompt, we can see that multiple levels of array nesting will uniformly apply this definition:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>:t [[[1,2],[3,4]], [[5,6],[7,8]]] </p>
</blockquote>
<p>[[[int]]] </p><blockquote class="doxtable">
<p>show([[[1,2],[3,4]], [[5,6],[7,8]]]) </p>
</blockquote>
<p>"[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"</p>
<blockquote class="doxtable">
<p>:t [[1,2,3,4], [5,6,7,8]] </p>
</blockquote>
<p>[[int]] </p><blockquote class="doxtable">
<p>show([[1,2,3,4], [5,6,7,8]]) </p>
</blockquote>
<p>"[[1, 2, 3, 4], [5, 6, 7, 8]]"</p>
<blockquote class="doxtable">
<p>:t [1,2,3,4,5,6,7,8] </p>
</blockquote>
<p>[int] </p><blockquote class="doxtable">
<p>show([1,2,3,4,5,6,7,8]) </p>
</blockquote>
<p>"[1, 2, 3, 4, 5, 6, 7, 8]" </p><div class="fragment"><div class="line">We can further expand the set of types in `Show` if we consider tuples in a similar way to arrays.  In this case, tuples are intentionally designed to be heterogeneously-typed unlike arrays, so we don&#39;t have a function as simple as `map` to evaluate across them.  However, we can make a new type class to fill a similar role:</div></div><!-- fragment --><p> class ShowTuple p where showTuple :: p -&gt; [[char]] </p><div class="fragment"><div class="line">And we can use a special constraint `p=(h*t)` to deconstruct the tuple within an instance generator (where we bottom out in the unit type `()` when the tuple is fully considered):</div></div><!-- fragment --><p> instance (p=(h*t), Show h, ShowTuple t) =&gt; ShowTuple p where showTuple p = [show(p.0)] ++ showTuple(tupleTail(p)) instance ShowTuple () where showTuple _ = [] </p><div class="fragment"><div class="line">Now with these definitions, we can determine the same intermediate string array that we determined for arrays.  All that we need to bring this into `Show` is to use the same `cdelim` method:</div></div><!-- fragment --><p> instance (ShowTuple p) =&gt; Show p where show p = "(" ++ cdelim(showTuple(p), ", ") ++ ")" </p><div class="fragment"><div class="line">And running this at the prompt, together with the prior definitions for `Show`, we can show even more complex types:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>show(42) </p>
</blockquote>
<p>"42" </p><blockquote class="doxtable">
<p>show((42,[1,2,3])) </p>
</blockquote>
<p>"(42, [1, 2, 3])" </p><blockquote class="doxtable">
<p>show((42,[1,2,3],[(4,5),(6,7)])) </p>
</blockquote>
<p>"(42, [1, 2, 3], [(4, 5), (6, 7)])" </p><div class="fragment"><div class="line">So far we have considered `Show` as an example of a typical type class, but sometimes we need to consider multiple types in combination.  For example, we might try a simple type class for overloaded addition:</div></div><!-- fragment --><p> class Addable a b c where (+) :: (a,b) -&gt; c </p><div class="fragment"><div class="line">And assuming that we have a function `iadd :: (int,int) -&gt; int` for the primitive CPU instruction for addition of integers, we might try introducing the instance:</div></div><!-- fragment --><p> instance Addable int int int where (+) = iadd </p><div class="fragment"><div class="line">And this would certainly work, but if we try to use this at the prompt we should get an error:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>1 + 2 </p>
</blockquote>
<p>stdin:1,1-5: Failed to compile expression due to unresolved type constraints: Addable int int a Print a </p><blockquote class="doxtable">
<p></p>
<p></p>
</blockquote>
<div class="fragment"><div class="line">The problem here is that hobbes wasn&#39;t able to infer a result type.  If we explicitly annotate the result type it will work:</div></div><!-- fragment --> <blockquote class="doxtable">
<p>(1+2)::int </p>
</blockquote>
<p>3 </p><blockquote class="doxtable">
<p>(3+4)::int </p>
</blockquote>
<p>7 </p><div class="fragment"><div class="line">However, this is an extremely inconvenient restriction and could easily become even more absurd for more complex types or multiple successive sums.  In short, we need some way to communicate to type inference and instance selection that although the result type of addition may vary, it is uniquely determined by the first two types.  Currently in hobbes, the way to address this problem is with [functional dependencies](http://web.cecs.pdx.edu/~mpj/pubs/fundeps-esop2000.pdf).  In short, when we define our type class we include with it the fact that the third type is _uniquely determined_ by the first two:</div></div><!-- fragment --><p> class Addable a b c | a b -&gt; c where (+) :: (a,b) -&gt; c </p><div class="fragment"><div class="line">With this change, we no longer need to introduce an explicit type annotation for the result -- instance selection will search just based on the first two types and then will communicate back to type inference that `c=int` for the single instance that it finds.</div><div class="line"></div><div class="line">More examples and applications of type classes can be found in the `hobbes/boot/` scripts, which are loaded whenever a `hobbes::cc` instance is constructed in C++ or when the `hi` program is initially run.</div><div class="line"></div><div class="line">An important distinction between the interpretation of type classes in hobbes and in Haskell is that hobbes does not use the common [dictionary-passing transform](http://okmij.org/ftp/Computation/typeclass.html#dict) for overloaded identifiers.  Instead, hobbes requires that any type constraint must also come with some logic that, for any _satisfied_ constraint, can _rewrite_ an expression involving that constraint into an equivalent expression without it.  For example, at the `hi` prompt with our `Show` example, we can use the `:u` command to show the result of this process just on the expression level (here with obvious type annotations removed):</div></div><!-- fragment --> <blockquote class="doxtable">
<p>:u show(42) </p>
</blockquote>
<p>showInt(42) </p><div class="fragment"><div class="line">This distinction is important because is allows hobbes to derive more efficient machine code than if dictionaries of indirect functions were passed around (though the approach is well known and has its drawbacks as well).</div><div class="line"></div><div class="line">## Unqualifier Modules &lt;a name=&quot;unqualifiers&quot;&gt;&lt;/a&gt;</div><div class="line"></div><div class="line">The C++ interface to hobbes supports the introduction of custom &quot;unqualifiers&quot; (and the system of type classes described earlier is just one such &quot;unqualifier&quot; implementation).  The standard set of unqualifiers is defined in `hobbes/lang/preds/` but it&#39;s possible to introduce your own by implementing the `Unqualifier` interface, which allows all of the mechanisms described so far.  This definition is located in `hobbes/lang/tyunqualify.H`:</div></div><!-- fragment --><p> struct Unqualifier { // bind any implied type variables in a constraint virtual bool refine(const TEnvPtr&amp; tenv, const ConstraintPtr&amp; cst, MonoTypeUnifier* u, Definitions* ds) = 0;</p>
<p>// determine whether or not this constraint is satisfied virtual bool satisfied(const TEnvPtr&amp; tenv, const ConstraintPtr&amp; cst, Definitions* ds) const = 0;</p>
<p>// determine whether or not it's possible to satisfy this constraint virtual bool satisfiable(const TEnvPtr&amp; tenv, const ConstraintPtr&amp; cst, Definitions* ds) const = 0;</p>
<p>// why couldn't this constraint be eliminated? virtual void explain(const TEnvPtr&amp;, const ConstraintPtr&amp;, const ExprPtr&amp;, Definitions*, annmsgs*) = 0;</p>
<p>// resolve a qualified expression virtual ExprPtr unqualify(const TEnvPtr&amp; tenv, const ConstraintPtr&amp; cst, const ExprPtr&amp; e, Definitions* ds) const = 0;</p>
<p>// allow overloaded symbols (as in type classes) virtual PolyTypePtr lookup(const std::string&amp; vn) const = 0;</p>
<p>// list overloaded symbols (if any) virtual SymSet bindings() const = 0;</p>
<p>// list functional dependencies between constraint parameters (if any) virtual FunDeps dependencies(const ConstraintPtr&amp;) const = 0; }; ```</p>
<p>The key functions to implement for your own constraint unqualifiers here are:</p>
<ul>
<li><code>refine</code>, which can infer parts of a constraint from other parts</li>
<li><code>satisfied</code>, which decides whether a constraint is fully satisfied</li>
<li><code>unqualify</code>, which rewrites an expression with a satisfied constraint into an equivalent expression without that constraint</li>
</ul>
<p>It is usually not necessary to introduce new unqualifiers this way, but it can be a very useful tool when all other options are insufficient. Once you've defined an implementation of this interface for your own compiler module, you can install it with <code>hobbes::cc::typeEnv()-&gt;bind("ConstraintName", UnqualifierPtr(new P()))</code> assuming that your type is <code>P</code> and you want it to resolve constraints named <code>"ConstraintName"</code>.</p>
<p>Why might you decide to implement your own unqualifier module? Ultimately this will come down to the particulars of your use-case, but in general this is a good option if you need to configure an external resource at an initial stage in order to query it arbitrarily at a subsequent stage.</p>
<p>For example, we've seen earlier that hobbes has a <code>LoadFile</code> constraint that takes a compile-time string (the path to a structured data file) and a type variable. The <code>Unqualifier</code> implementation that handles this constraint (in <code>hobbes/db/bindings.C</code>) will load the file <em>at compile-time</em>, determine its type structure, and will <code>refine</code> (or unify) the constraint's second argument to this type structure to allow subsequent type checking and compilation against the file's contents. There's also an <code>AddDBFieldSignal</code> constraint defined in <code>hobbes/db/signals.C</code> to handle the previously-mentioned installation of callbacks or "tails" to react to updates in structured file data (eventually reducing to an interaction between <code>epoll</code> and <code>inotify</code> on Linux). The addition of these unqualifier modules together allows a kind of flexible "dynamic, duck-typing" scripting against recorded data without giving up type checking or compilation of efficient code to react/query recorded data.</p>
<p>Another example we've seen earlier is the hobbes <code>Connect</code> constraint. This also takes a compile-time string and produces a unique type representing the connection made at compile-time. This is used further (and with other supporting constraints/unqualifiers) to negotiate a protocol and derive efficient code to communicate with a remote process.</p>
<p>These are just some examples of extensions to hobbes through the <code>Unqualifier</code> interface, but there are undoubtedly many other ways that this option can be useful to applications using hobbes. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
